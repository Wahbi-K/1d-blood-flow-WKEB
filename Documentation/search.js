window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "Blood_Flow_1D", "modulename": "Blood_Flow_1D", "qualname": "", "type": "module", "doc": "<p>Blood Flow Simulator</p>\n\n<h1 id=\"module-contents\">Module contents</h1>\n\n<p>\"Blood_Flow_1D\" contains the python code.</p>\n\n<p>\"DataFiles\" contains input files needed to run the models.</p>\n\n<p>\"Documentation\" contains the documentation.</p>\n\n<p>\"eventmodule\" contains the submodule eventmodule, needed to run an in silico trial.</p>\n\n<p>\"Generated_Patients\" contains some examples of patient simulations.</p>\n\n<p>\"Pulsatile_Model\" contains the source code of the pulsatile blood flow model.</p>\n\n<h1 id=\"documentation\">Documentation</h1>\n\n<p>Code documentation: <code>Documentation/index.html</code>\nList of input and output files: <code>Documentation/Input-Output Files list.xlsx</code>\nList of model parameters: <code>Documentation/Model_parameters.xlsx</code></p>\n\n<h1 id=\"1d-blood-flow\">1D Blood Flow</h1>\n\n<p>The 1-D blood flow model generates a patient from patient-specific data, literature values and high-resolution data from volunteers.</p>\n\n<h1 id=\"installation\">Installation</h1>\n\n<p>Installing required python modules (using conda env)</p>\n\n<p>Create an environment.\n<code>conda create -n 1d-blood-flow python=3.9</code></p>\n\n<p>Activate the environment.\n<code>conda activate 1d-blood-flow</code></p>\n\n<p>Install the blood flow module.\n<code>pip install ./</code></p>\n\n<p>Compile the BF Solver in the Pulsatile_Model folder by running msbuild or using monodevelop.\n<code>msbuild \"Pulsatile_Model/Blood Flow Model.sln\"</code></p>\n\n<p>The executable location is located in Pulsatile_Model/Blood Flow Model/bin/Debug/\n(If necessary, run <code>chmod +x BloodflowModel.exe</code>)</p>\n\n<h1 id=\"running-the-model\">Running the model</h1>\n\n<p>Run a bunch of examples with:\n<code>./run_examples.sh</code></p>\n\n<p>Remember to run the code from within the conda env.</p>\n\n<h2 id=\"generating-simulation-files\">Generating simulation files</h2>\n\n<p>(see input files for required files)</p>\n\n<p>In the script folder, run GenerateBloodflowFiles.py with patient folder location.\nThe example patient in Generated_Patients/patient_0/ contains a generated patient ready for the BF solver.\n<code>python3 Blood_Flow_1D/GenerateBloodflowFiles.py Generated_Patients/patient_0/</code></p>\n\n<h2 id=\"blood-flow-simulations\">Blood flow simulations</h2>\n\n<p>Two models can be used to simulate blood flow.</p>\n\n<p>Run BloodFlowSimulator.py with executable location, patient folder location, and an boolean argument whether the clot should be included.\nNote that the Blood_flow_1D folder location is needed by the bf solver and is listed in Model_parameters.txt. The location is updated during the patient generation but can be different if the patient is generated on other machines.</p>\n\n<p><code>python3 Blood_Flow_1D/BloodFlowSimulator.py &lt;executable location&gt; &lt;patient folder path&gt; &lt;include clot&gt;</code></p>\n\n<h3 id=\"for-pulsatile-flow-simulations\">For pulsatile flow simulations</h3>\n\n<p>The executable location is located in Pulsatile_Model/Blood Flow Model/bin/Debug/</p>\n\n<p>(If necessary, run <code>chmod +x BloodflowModel.exe</code>)</p>\n\n<p>Set Model=Pulsatile in the model_parameters.txt file to use this model.</p>\n\n<p><code>python3 Blood_Flow_1D/BloodFlowSimulator.py \"Pulsatile_Model/Blood Flow Model/bin/Debug/BloodflowModel.exe\" Generated_Patients/patient_0/ False</code></p>\n\n<h3 id=\"for-steady-state-flow-simulations\">For steady state flow simulations</h3>\n\n<p>Set Model=Steady in the model_parameters.txt file to use this model.</p>\n\n<p><code>python3 Blood_Flow_1D/BloodFlowSimulator.py . Generated_Patients/patient_0/ False</code></p>\n\n<h2 id=\"additional-modelling\">Additional modelling</h2>\n\n<h3 id=\"detailed-collateral-model\">Detailed Collateral Model</h3>\n\n<p>The Collateral model can be run after the patient files are generated or new files can be generated by setting GenerateNewFiles=True. The model can be run by calling CollateralsSimulation.py with the location of the patient folder.\nThe collateral model uses the steady state model by default.</p>\n\n<p><code>python3 Blood_Flow_1D/CollateralsSimulation.py Generated_Patients/patient_0/</code></p>\n\n<h3 id=\"contrast-model\">Contrast Model</h3>\n\n<p>The Contrast model can be run after the blood flow simulation by calling ContrastModel.py, a boolean and a duration.\nTrue if the steady model has used, False for pulsatile model (option will be removed in future update).</p>\n\n<p><code>python3 Blood_Flow_1D/ContrastModel.py Generated_Patients/patient_0/ False 10</code></p>\n\n<h1 id=\"notes\">Notes</h1>\n\n<p>Installing scikits.umfpack also enables using UMFPACK solver via some of the scipy.sparse.linalg functions, for SciPy &gt;= 0.14.0.</p>\n"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "", "type": "module", "doc": "<p>Equations related to simulating blood flow.\nContains a 1-D pulsatile blood flow solver (WIP).</p>\n"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.flux_function", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "flux_function", "type": "function", "doc": "<p>Inlet function to solve\nRelated to the method of caracteristics\n:param self: node\n:param area: guess value\n:return: residual</p>\n", "parameters": ["self", "area"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.chrt_function", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "chrt_function", "type": "function", "doc": "<p>Characteristic function for the outlets.\nRelated to the method of caracteristics\n:param self:\n:param area:\n:return:</p>\n", "parameters": ["self", "area"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.thickness", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "thickness", "type": "function", "doc": "<p>Emperical function to calculate vessel thickness given the radius.\n:param r: radius defined in mm\n:return: thickness defined in mm</p>\n", "parameters": ["r"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.SolveOutletRCR", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "SolveOutletRCR", "type": "function", "doc": "<p>Method to solve for the state variables for the next iteration at the outlets.\n:param args: tuble: outlet node, previous node.\n:return: Nothing</p>\n", "parameters": ["args"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.SolveInlet", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "SolveInlet", "type": "function", "doc": "<p>Method to solve for the state variables for the next iteration at the inlets.\n:param args: tuble: inlet node, previous node.\n:return: Nothing</p>\n", "parameters": ["args"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.Bifurcation", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "Bifurcation", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.Bifurcation.__init__", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "Bifurcation.__init__", "type": "function", "doc": "<p>Initiate the bifurcation with a set of nodes and their positive direction.\n:param nodes: list of nodes connected to this bifurcation\n:param signs: list of signs that define the positive direction of flow at the nodes</p>\n", "parameters": ["self", "nodes", "signs"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.Bifurcation.funcs", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "Bifurcation.funcs", "type": "function", "doc": "<p>Functions to minimize at the bifurcations.\n1) mass conservation\n2) continuity of characteristics\n3) continuity of pressure\n:param values: List of flow velocity and area (lumen) at the connected nodes.\n:return: residuals</p>\n", "parameters": ["self", "values"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.Bifurcation.Jac", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "Bifurcation.Jac", "type": "function", "doc": "<p>Method to compute the jacobian of funcs at the bifurcation.\n:param values: List of flow velocity and area (lumen) at the connected nodes.\n:return: Jacobian</p>\n", "parameters": ["self", "values"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.Bifurcation.SolveBif", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "Bifurcation.SolveBif", "type": "function", "doc": "<p>Method to update the state variables for the next iteration.\nFunctions to minimize at the bifurcations.\n1) mass conservation\n2) continuity of characteristics\n3) continuity of pressure\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.SolvingBif", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "SolvingBif", "type": "function", "doc": "<p>Method to call the solve bifurcation function in parallel.\n:param args: bifurcation\n:return: Nothing</p>\n", "parameters": ["args"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.SolveVessel", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "SolveVessel", "type": "function", "doc": "<p>Maccormack method to solve the for the state variables inside a vessel.\n:param vessel: Vessel to solve.\n:return: Nothing</p>\n", "parameters": ["vessel"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.flowrate", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "flowrate", "type": "function", "doc": "<p>Function from Boileau2015 (scaled inflow from common carotid)\nscaling 1 found give 1ml/s\n:param t: Current time\n:param Period: Period of the function\n:param scaling: Scaling to obtain an integrated volume flow rate equal to this param.\n:return: Flow value</p>\n", "parameters": ["t", "Period", "scaling"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.FlowRateAorta", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "FlowRateAorta", "type": "function", "doc": "<p>Function from Boileau2015 (scaled inflow )\nBenchmark6_ADAN56\nscaling 1 found give 1ml/s\n:param t: Current time\n:param period: Period of the function\n:param scaling: Scaling to obtain an integrated volume flow rate equal to this param.\n:return: Flow value</p>\n", "parameters": ["t", "period", "scaling"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.FlowRateAlastruey2007", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "FlowRateAlastruey2007", "type": "function", "doc": "<p>Function from Alastruey2007\n:param timevalues: time values to return flow rates at.\n:param scaling: scaling of the flow, scaling 1 found give 1ml/s\n:return: calculate flow rates.</p>\n", "parameters": ["timevalues", "scaling"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.FlowRateAlastruey2007function", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "FlowRateAlastruey2007function", "type": "function", "doc": "<p>Updated function from FlowRateAlastruey2007\n:param t: Current time\n:param period: Period of the function\n:param scaling: Scaling to obtain an integrated volume flow rate equal to this param.\n:return: Flow value</p>\n", "parameters": ["t", "period", "scaling"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.FlowRateAorta2", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "FlowRateAorta2", "type": "function", "doc": "<p>Function from Boileau2015 (scaled inflow )\nBenchmark4_AorticBifurcation\nscaling 1 found give 1ml/s\n:param t: Current time\n:param period: Period of the function\n:param scaling: Scaling to obtain an integrated volume flow rate equal to this param.\n:return: Flow value</p>\n", "parameters": ["t", "period", "scaling"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.Bloodflow1D", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "Bloodflow1D", "type": "function", "doc": "<p>Function to simulation pulsatile blood flow in the system defined in self.\n:param self: patient object.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.murraylaw", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "murraylaw", "type": "function", "doc": "<p>Function to calculate the radius of daughter branches based on Murray's law.\nAssume symmetric branches.\n:param radius: Mother radius\n:param exponent: exponent of Murray's law: default:3\n:return: Daughter radius</p>\n", "parameters": ["radius", "exponent"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowEquations.RadiusToLength", "modulename": "Blood_Flow_1D.BloodFlowEquations", "qualname": "RadiusToLength", "type": "function", "doc": "<p>Function to calculate the length of a vessel based on its radius.\nThis function multiplies the radius with a radius-to-length ratio.\nRatio is set at 10.\n:param radius: radius\n:param ratio: Length-radius ratio, default:10\n:return: length</p>\n", "parameters": ["radius", "ratio"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.BloodFlowSimulator", "modulename": "Blood_Flow_1D.BloodFlowSimulator", "qualname": "", "type": "module", "doc": "<p>1D Blood Flow Simulator\nScript to run a blood flow simulation using a previously generated patient.\nThe blood flow model can be pulsatile or steady state.\nClots can be included in the blood flow model.</p>\n\n<p>Three inputs are needed.\n<executable_location> is the location of the executable for the pulsatile blood flow simulations.\nIf the steady state model is used, the argument can be anything.</p>\n\n<p><patient_folder> argument is the patient folder with a folder for input files and a folder for modelling files\nThe input folder contains patient data.\nThe modelling file folder contains files for the models such as the parameters and the surface mesh.</p>\n\n<p>--clot_present is a flag that indicates clots are to be simulated by the models.</p>\n\n<p>Usage:\n  BloodFlow.py <executable_location> <patient_folder> [--clot_present]\n  BloodFlow.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.\n  --clot_present        Simulations consider clots.</p>\n"}, {"fullname": "Blood_Flow_1D.BloodFlowSimulator.blood_flow_script", "modulename": "Blood_Flow_1D.BloodFlowSimulator", "qualname": "blood_flow_script", "type": "function", "doc": "<p>Function to run a blood flow simulation on a previously generated patient.\nOption to choose between pulsatile and steady state models.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>executable : str\n    Location of BloodflowModel.exe\npatient_folder : str\n    Location of patient folder\nclot_present : boolean\n    True or False if clot should be included in the simulations</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>patient : patient object\n    patient object containing network and results.</p>\n", "parameters": ["executable", "patient_folder", "clot_present"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Check_Convergence", "modulename": "Blood_Flow_1D.Check_Convergence", "qualname": "", "type": "module", "doc": "<p>Script to calculate whether the 1-D pulsatile model has converged.</p>\n"}, {"fullname": "Blood_Flow_1D.Collaterals", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "", "type": "module", "doc": "<p>Functions related to the pial network model.</p>\n"}, {"fullname": "Blood_Flow_1D.Collaterals.overlapregion", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "overlapregion", "type": "function", "doc": "<p>Add triangles to the clusters. Add the closest triangle until we have increased the area with the input percentage\nCalculate the overlap by finding connected triangles\n:param patient: patient object\n:param areaincrease: percentage of increase in area\n:return: Nothing</p>\n", "parameters": ["patient", "areaincrease"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ExportOverlappingRegions", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ExportOverlappingRegions", "type": "function", "doc": "<p>Export the overlapping regions to a file.\n:param patient: patient object\n:return: Regions.vtp and SurfaceNodesMapping.csv</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.CreatePialNetwork", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "CreatePialNetwork", "type": "function", "doc": "<p>Determine the dual graph as the pial network and set regions based on clustering\n:param surfacefile: The primary graph to use as a template for the pial network.\n:param separation: Method to determine where the collateral vessels are. Default: majorregions, (other option:clusters)\n:param collateralscore: probability to include any particular collateral vessel in the pial network.\n:return: perfusion object, node positions, edges, collateral edges</p>\n", "parameters": ["surfacefile", "separation", "collateralscore"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.GenerateVessels", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "GenerateVessels", "type": "function", "doc": "<p>Generate simple vessels for the pial network. Every vertix is a node and every edge is a vessel.\n:param patient: patient object\n:param nodepositions: 3d positions of the pial network nodes\n:param edges: edges of the pial network\n:param colleratalEdges: edged that belong to the collateral system\n:param PialnetworkRadius: radius of every vessel of the pial network\n:return: list of collateral vessels, pial network nodes, pial network vessels and nodes that belong to the edges.</p>\n", "parameters": ["patient", "nodepositions", "edges", "colleratalEdges", "PialnetworkRadius", "Connecting"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.SetPAOutlets", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "SetPAOutlets", "type": "function", "doc": "<p>Calculate the resistance for the penerating arteries and assign it.\n:param patient: patient object\n:param brainperfusionestimate: estimate of the volume flow rate to the entire brain (through the PAs)\n:param pialsurfacepressure: pressure at the pial surface in pa.\n:param venouspressure: venous pressure at the start of the venous system.s\n:return: None.</p>\n", "parameters": ["patient", "brainperfusionestimate", "pialsurfacepressure", "venouspressure"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.PAfromFile", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "PAfromFile", "type": "function", "doc": "<p>Load a surface file and use the vertices as the location of the penetrating arteries.\nMap the penetrating arteries to the nearest pial network node.\n:param file: surface file\n:param nodes: nodes of the pial network\n:return: list of penetrating artery position, edges between the PAs and the nodes.</p>\n", "parameters": ["file", "nodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.GeneratePAs", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "GeneratePAs", "type": "function", "doc": "<p>Generate penetrating arteries on a surface uniformly.\n:param graph: Graph object, surface used to generate the penetrating arteries.\n:param n: number of penetrating arteries to generate.\n:return: position of the penetrating artery, connections to the nearest triangle of the surface.</p>\n", "parameters": ["graph", "n"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.SplitRegionInTwo", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "SplitRegionInTwo", "type": "function", "doc": "<p>Split a set of points in two based on distance.\n:param points: points to divide\n:param PialDMat: distance matrix\n:param debug: Boolean to set debu mode. Debug mode randomly splits the region in two.\n:return: Region1, Region2</p>\n", "parameters": ["points", "PialDMat", "debug"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.TreeToSurfaceMapping", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "TreeToSurfaceMapping", "type": "function", "doc": "<p>Map bifurcating trees to the pial surface by iterative division of the regions.\nUpdated method at TreeToSurfaceMappingMetis()\n:param patient: patient object\n:param distancemat: distance matrix\n:param debug: dBoolean to set debu mode. Debug mode randomly splits the region in two.\n:param method: distance method.\n:return: Nothing</p>\n", "parameters": ["patient", "distancemat", "debug", "method"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.TreeToSurfaceMappingMetis", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "TreeToSurfaceMappingMetis", "type": "function", "doc": "<p>Split the perfusion territories iteratively to map the bifurcating trees to the surface.\nThe regions are split iteratively so that ends close together remain close on the surface.\nThe center final region of each treeis set as the coupling point.\n:param patient: patient object\n:return: None</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ExportTreeEndNodePositions", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ExportTreeEndNodePositions", "type": "function", "doc": "<p>Export the location of the trees on the pial surface. The coupling point number (tree number) are included.\n:param patient: patient object\n:param filename: exported vtp file\n:return: Nothing</p>\n", "parameters": ["patient", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.WriteRegionsSplitsToVTP", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "WriteRegionsSplitsToVTP", "type": "function", "doc": "<p>Export the split regions to a file.\n:param patient: patient object\n:param file: default:\"RegionSplitting.vtp\"\n:return: Nothing</p>\n", "parameters": ["patient", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.RemoveUnconnectedSections", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "RemoveUnconnectedSections", "type": "function", "doc": "<p>Filter vessels outside main network.\nNote that the assumption at this time is that the inlet is node 0.\n:param patient: patient object\n:return: None.</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.PialNetworkToPatientTopology", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "PialNetworkToPatientTopology", "type": "function", "doc": "<p>The pial network is defined as a set of bifurcation nodes.\nThis function creates proper vessels from the network.\n:param pialnetworkvessels: vessels to be updated\n:param patient: Patient object\n:return: None.</p>\n", "parameters": ["pialnetworkvessels", "patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ExportSimulationResults", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ExportSimulationResults", "type": "function", "doc": "<p>Create figures and export data from pial network simulation\n:param patient: patient object\n:param healthy: Boolean (default:True) This changes the filenames so that files are not overwritten.\n:return: ClusterFlowData.csv, ResultsPerVessel.csv, Topology.vtp, Results.dyn, FlowRateHistograms.png</p>\n", "parameters": ["patient", "healthy"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.CalculatePressureDrop", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "CalculatePressureDrop", "type": "function", "doc": "<p>Collateral measure and pressure difference across clots in the patient network.\n:param patient: patient object.\n:return: None.</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ExportSystemResult", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ExportSystemResult", "type": "function", "doc": "<p>Function to output important results from the collateral simulation.\nNote: run this after the graph contrast model.\n:param patient: patient object\n:param folder: location to store the csv\n:param file: csv name\n:return: None</p>\n", "parameters": ["patient", "folder", "file", "figname", "figname2"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ExportResultsToPAfile", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ExportResultsToPAfile", "type": "function", "doc": "<p>Map results to the PA file.\n:param patient: patient object\n:param file: PA file\n:param healthy: bool (default:True). Choose between healthy and clot, this affects the name of the arrays added.\n:return: None.</p>\n", "parameters": ["patient", "file", "healthy", "cellArray"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ExportPAnodes", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ExportPAnodes", "type": "function", "doc": "<p>Exporting the order of the PAnodes.\nThis file is required to easily map the surface files with the topology files.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    patient object with data.</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.ImportPAnodes", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "ImportPAnodes", "type": "function", "doc": "<p>Import the order of the PANodes.\nThe first column is the number of the cell or point in the surface files.\nThe second column is the node number in the topology file.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.GenerateTreesFromResistance", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "GenerateTreesFromResistance", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.add_network_pa_nodes", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "add_network_pa_nodes", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Collaterals.estimate_perfusion", "modulename": "Blood_Flow_1D.Collaterals", "qualname": "estimate_perfusion", "type": "function", "doc": "<p>Get perfusion values.\nSet brainperfusionestimate in model parameters to this value.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient: patient object</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.CollateralsSimulation", "modulename": "Blood_Flow_1D.CollateralsSimulation", "qualname": "", "type": "module", "doc": "<p>Collateral Simulator</p>\n\n<p>Script to run a simulation of the pial network.\nInput argument is the patient folder with a folder for input files and a folder for modelling files\nThe input folder contains patient data and the modelling file folder contains files for the models\nsuch as the parameters and the surface mesh.</p>\n\n<p>Usage:\n  tavernaBloodFlow.py <patient_folder>\n  tavernaBloodFlow.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.CollateralsSimulation.collateral_simulation", "modulename": "Blood_Flow_1D.CollateralsSimulation", "qualname": "collateral_simulation", "type": "function", "doc": "<p></p>\n", "parameters": ["patient", "clot_active", "lower_bound_mmhg", "upper_bound_mmhg"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.CollateralsSimulation.CollateralSimulation", "modulename": "Blood_Flow_1D.CollateralsSimulation", "qualname": "CollateralSimulation", "type": "function", "doc": "<p>This function loads the model, adds the collaterals, and runs both healthy and stroke simulations.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient_folder : str\n    Patient folder location</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["patient_folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Constants", "modulename": "Blood_Flow_1D.Constants", "qualname": "", "type": "module", "doc": "<p>Contains constants and dictionaries used in the model.</p>\n"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "", "type": "module", "doc": "<p>Contrast delay calculator based on graphs.\nDijkstra's algorithm is used to determine the shortest path.</p>\n\n<p>Usage:\n  ContrastGraphModel.py <patient_folder> <correct>\n  ContrastGraphModel.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.CalculateTimeDelay", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "CalculateTimeDelay", "type": "function", "doc": "<p>Calculate timedelay from the inlet at node 0 to every other node in the network.\nThe delay per edge is calculated as dx/v where v is the mean velocity and dx is the separation.\n:param patient: patient object\n:return: None.</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.CalculatePerfusionTerritories", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "CalculatePerfusionTerritories", "type": "function", "doc": "<p>Using dijkstra's algorithm, calculate downstream nodes and the perfusion territories.\n:param patient: patient object\n:param PAfile: PAfile to write the perfusion territories to.\n:return: Nothing</p>\n", "parameters": ["patient", "PAfile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.WriteTimeDelays", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "WriteTimeDelays", "type": "function", "doc": "<p>Save the time delays in a csv file.\n:param patient: patient object\n:param file: timedelay file name\n:return: None.</p>\n", "parameters": ["patient", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.AddTimeDelaysToTopologyFile", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "AddTimeDelaysToTopologyFile", "type": "function", "doc": "<p>Add time delays to the patient topology file.\n:param patient: patient object\n:param file: topology file name\n:return: None.</p>\n", "parameters": ["patient", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.BoundaryUpdateMatrix", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "BoundaryUpdateMatrix", "type": "function", "doc": "<p></p>\n", "parameters": ["patient", "numberNodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.ContrastGraphModel", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "ContrastGraphModel", "type": "function", "doc": "<p>Load patient files and calculate the time delay through the patient network.\nThe velocity used is the mean velocity of each edge.\nA timedelay.csv is created and the delays are added to the topology file.</p>\n\n<p>correctness: True if direction at the outlets is the same as the internal nodes.\nFalse if direction is opposite that of the internal nodes.\nTrue if steady model has used, False for pulsatile model.\n:param patient_folder: location of patient folder\n:param correctness: Default:True\n:return: None.</p>\n", "parameters": ["patient_folder", "correctness"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.ContrastPathSum", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "ContrastPathSum", "type": "function", "doc": "<p>Calculate the expected contrast profile based on the sum of paths.\nResults are saved in the simulation folder.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    patient object containing all data</p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.CalculateContrastProfile", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "CalculateContrastProfile", "type": "function", "doc": "<p>Calculate the contrast profile at Node B.\nInlet node is NodeA.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    object containing patient data\nNodeA : Node\n    Initial node\nNodeB : Node\n    Target node</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Finalprofile: list of floats\n    The sum of all individual profiles given in profiles.\nprofiles : list of list of floats\n    The shortest paths between NodeA and NodeB\ntime : list of floats\n    Time points belonging to the profiles\npeaks : list of integers\n    List of indexes that belong to peaks in Finalprofile</p>\n", "parameters": ["patient", "NodeA", "NodeB"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastGraphModel.InletFunction", "modulename": "Blood_Flow_1D.ContrastGraphModel", "qualname": "InletFunction", "type": "function", "doc": "<p>Contrast inlet function\nShifted Gaussian with the peak at t=0.15s</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>time : float\n    imput time parameter</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : float\n    Value at the imput time</p>\n", "parameters": ["time"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "", "type": "module", "doc": "<p>Contrast advection simulator</p>\n\n<p>Usage:\n  ContrastModel.py <patient_folder> <correct> <duration>\n  ContrastModel.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.ContrastModel.boundaryUpdateMatrix", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "boundaryUpdateMatrix", "type": "function", "doc": "<p>Calculate the matrix to update the bifurcation nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : Patient object\n    patient object with patient and flow data\nnumber_nodes: : int\n    Number of nodes in the matrix</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bifurcationMatrix : scipy.lilmatrix\n    sparse matrix that calculates the concentration of the nodes at the start of the bifurcation</p>\n", "parameters": ["patient", "number_nodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.contrast_clot_ends", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "contrast_clot_ends", "type": "function", "doc": "<p>Create figures of the contrast profiles at the proximal and distal parts of a vessel with a clot.\nFigures are saved in the modelling folder. Time delay values are stored in ContrastDelay.csv</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fig : matplotlib figure</p>\n", "parameters": ["patient", "hdf5DataFile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.contrastMatrixUpwind", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "contrastMatrixUpwind", "type": "function", "doc": "<p>Generate matrix using the upwind numerical scheme.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    patient object with vasculature and flow data\ndt : float\n    Time step</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mtx : scipy.csc_matrix\n    matrix obtained\ninputvection : matrix with zeros\n    Initial condution\nnodesetlist : list\n    List of nodes in the order that they appear in the matrix.</p>\n", "parameters": ["patient", "dt"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.contrastSimulationUpwind", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "contrastSimulationUpwind", "type": "function", "doc": "<p>Simulation of contrast through the patient vasculature.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>clot_contrast_disable: disable contrast after the clot\nnumber_output_files\nhdf5DataFile\ninlet_section\npatient : patient object\n    patient object with flow data\nsimulationtime : float\n    duration of the simulation</p>\n", "parameters": ["patient", "simulationtime", "number_output_files", "hdf5DataFile", "inlet_section", "clot_contrast_disable"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.writeContrastPAnodes", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "writeContrastPAnodes", "type": "function", "doc": "<p>Write the results of the contrast simulation to file.\nOutput is written to ResultsContrastPA.pvd</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    patient object with simulation results.</p>\n", "parameters": ["patient", "hdf5DataFile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.writeContrastPAnodesSurface", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "writeContrastPAnodesSurface", "type": "function", "doc": "<p>Write the results of the contrast simulation to file.\nOutput is written to ResultsContrastPASurface.pvd</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    patient object with simulation results.</p>\n", "parameters": ["patient", "hdf5DataFile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.writeContrastVessels", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "writeContrastVessels", "type": "function", "doc": "<p>Write the results of the contrast simulation to file.\nOutput is written to ResultsContrast.pvd</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient : patient object\n    patient object with simulation results.</p>\n", "parameters": ["patient", "hdf5DataFile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.ContrastModel.run_contrast_model", "modulename": "Blood_Flow_1D.ContrastModel", "qualname": "run_contrast_model", "type": "function", "doc": "<p>Load patient files and calculate the time delay through the patient network.\nThe velocity used is the mean velocity of each edge.\nA timedelay.csv is created and the delays are added to the topology file.</p>\n\n<p>correctness: True if direction at the outlets is the same as the internal nodes.\nFalse if direction is opposite that of the internal nodes.\nTrue if steady model has used, False for pulsatile model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient_folder : String\n     location of patient folder\ncorrectness : Boolean\n    Does the model need to update the flow data at the outlets?\n    Pulsatile model output requires correction.\nduration : float\n    duration of the contrast simulation</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>patient: patient object\n    patient object with results.</p>\n", "parameters": ["patient_folder", "correctness", "duration", "number_output_files", "resultfile", "hdf5_file", "output_time_series", "inlet_section"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Fragments", "modulename": "Blood_Flow_1D.Fragments", "qualname": "", "type": "module", "doc": "<p>Fragment simulation</p>\n\n<p>Requires a file that specifies the fragmentation distribution in the patient folder: micro_thrombi_distribution.csv\nOptional file is the Results.dyn to be used to the micro-thrombi shower.</p>\n\n<p>Output in bf_sim:\n        Large_fragments.txt\n        Micro-thrombi.csv\n        Additional \"Clot\" array in Topology.vtp</p>\n\n<p>optional\n        Matlibplot figure of occlusion probability for all nodes:  \"ClotSize_Probability.png\"\n        Occlusion probability per node: ClotSize_Probability.csv\n        Occlusion probability per PAnode is using detailed collateral model: ClotSize_Probability_PAnodes.csv\n        Folder with occlusion probabilities for various clot sizes: FragmentsTopologySeries/*</p>\n\n<p>Usage:\n  Fragments.py <patient_folder> [<file>]\n  Fragments.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.Fragments.patient_loading", "modulename": "Blood_Flow_1D.Fragments", "qualname": "patient_loading", "type": "function", "doc": "<p></p>\n", "parameters": ["patient_folder", "results_file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Fragments.fragment_simulation", "modulename": "Blood_Flow_1D.Fragments", "qualname": "fragment_simulation", "type": "function", "doc": "<p>The goal is to get a probability curve per node (segment) of a clot getting stuck (as a function of radius).</p>\n\n<p>Load patient network, simulate healthy flow, track fragments.\nCreate a figure showing the probability function of all nodes.\nOutputs CSV files for nodes/PAnodes and the probability of blockages per clot size.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>sizes: list of fragment sizes.\nplot_example: boolean to plot probability for every node in the system\npatient_folder_location: patient folder location</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["patient_folder_location", "sizes", "results_file", "plot_example", "save_optional_results"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Fragments.probability_map", "modulename": "Blood_Flow_1D.Fragments", "qualname": "probability_map", "type": "function", "doc": "<p>Return a dict of nodes with non-zero probability of blockage for the given clot radius.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient_object: patient object\nradius: clot radius</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary of nodes and the probability of a clot fragment getting stuck at the node.</p>\n", "parameters": ["patient_object", "radius"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Fragments.micro_occlusion", "modulename": "Blood_Flow_1D.Fragments", "qualname": "micro_occlusion", "type": "function", "doc": "<p></p>\n", "parameters": ["patient_object", "thrombi_distribution", "run_sim"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Fragments.micro_thrombi", "modulename": "Blood_Flow_1D.Fragments", "qualname": "micro_thrombi", "type": "function", "doc": "<p></p>\n", "parameters": ["folder", "results_file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "", "type": "module", "doc": "<p>Contains static functions for general use.</p>\n"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.is_non_zero_file", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "is_non_zero_file", "type": "function", "doc": "<p>Return 1 if file exists and has data.\n:param fpath: path to file\n:return: boolean</p>\n", "parameters": ["fpath"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.TMatrix", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "TMatrix", "type": "function", "doc": "<p>4x4 rotation and translation matrix.\nOrder of transformation is translation, X-Y-Z rotation.\nScaling is isotropic\n:param scaling: scaling factor\n:param rotation: rotation angles: x,y,z values\n:param translation: translation values: x,y,z values\n:return: translation matrix</p>\n", "parameters": ["scaling", "rotation", "translation"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.TMatrixNonUniform", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "TMatrixNonUniform", "type": "function", "doc": "<p>4x4 rotation and translation matrix.\nOrder of transformation is translation, X-Y-Z rotation.\nScaling is non-isotropic\n:param scaling: scaling factor: x,y,z values\n:param rotation: rotation angles: x,y,z values\n:param translation: translation values: x,y,z values\n:return: translation matrix</p>\n", "parameters": ["scaling", "rotation", "translation"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.TriangleToArea", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "TriangleToArea", "type": "function", "doc": "<p>Take a list of node positions and return the area using Heron's formula.\n:param nodes: Set of points\n:return: area</p>\n", "parameters": ["nodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.meanpos", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "meanpos", "type": "function", "doc": "<p>Take a list of node positions and return the centroid (mean position).\n:param nodes: list of node positions\n:return: mean x,y,z coordinates</p>\n", "parameters": ["nodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.distancebetweenpoints", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "distancebetweenpoints", "type": "function", "doc": "<p>Calculate the euclidean distance between two points.\n:param p1: List of coordinates\n:param p2: List of coordinates\n:return:</p>\n", "parameters": ["p1", "p2"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.Merge", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "Merge", "type": "function", "doc": "<p>Merge a patient network with a brava network.\n:param patient: patient object containing the patient network\n:param brava:  patient object containing the brava network\n:return: Nothing</p>\n", "parameters": ["patient", "brava"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.TransformFile", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "TransformFile", "type": "function", "doc": "<p>Transform all points in a vtp or ply file.\nThis is not the way that paraview does its transformations.\n:param file: file to transform\n:param transformmatrix: transformation matrix, see TMatrix()\n:return: Nothing</p>\n", "parameters": ["file", "transformmatrix"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile", "type": "class", "doc": "<p>Class to read and write msh mesh files.</p>\n"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile.__init__", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile.Loadfile", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile.Loadfile", "type": "function", "doc": "<p>Load the msh file into the object.\n:param file: msh file\n:return: Nothing</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile.Writefile", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile.Writefile", "type": "function", "doc": "<p>Write the object to file\n:param file: file name\n:return: Nothing</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile.GetElements", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile.GetElements", "type": "function", "doc": "<p>Get the index and elements of the mesh at specific regions.\n:param ids: regions ids\n:return: elements, indexes</p>\n", "parameters": ["self", "ids"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile.GetSurfaceCentroids", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile.GetSurfaceCentroids", "type": "function", "doc": "<p>Get the centroids of the elements of the mesh\n:param ids: region ids of the elements\n:return: Positions, elements, indexes</p>\n", "parameters": ["self", "ids"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MSHfile.AreaRegion", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MSHfile.AreaRegion", "type": "function", "doc": "<p>Get the area of the elements of some region.\n:param regionid: region id of the elements\n:return: total area, number of triangles.</p>\n", "parameters": ["self", "regionid"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.VesselMapping", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "VesselMapping", "type": "function", "doc": "<h1 id=\"for-each-vesselnode-in-patient-map-them-to-the-same-vessel-in-the-mapping-file\">For each vessel/node in patient, map them to the same vessel in the mapping file.</h1>\n\n<h1 id=\"for-now-only-55-vessels-are-included\">For now, only 55 vessels are included.</h1>\n\n<p>:param mappingfile: vtp file containing 3d vessel network\n:param patient: patient object\n:return: Nothing</p>\n", "parameters": ["mappingfile", "patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MapClusteringToMSH", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MapClusteringToMSH", "type": "function", "doc": "<p>Mapping the clustered msh file to a nother msh file.\n:param file: msh file with clustering\n:param file2: target msh\n:param datafolder: folder containing files\n:return: Nothing</p>\n", "parameters": ["file", "file2", "datafolder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.MapPointsToMSH", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "MapPointsToMSH", "type": "function", "doc": "<p></p>\n", "parameters": ["points", "file2", "datafolder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.WriteFlowFilePerfusionModel", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "WriteFlowFilePerfusionModel", "type": "function", "doc": "<p>Output pressure and flow rate data to a boundary file for the perfusion network.\n:param Clusterflowdatafile: file containing blood flow variables\n:param clusteringfile: file containing clustering\n:param datafolder: outut folder\n:return: Nothing</p>\n", "parameters": ["Clusterflowdatafile", "clusteringfile", "datafolder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.slice_by_index", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "slice_by_index", "type": "function", "doc": "<p>Slice list by positional indexes.</p>\n\n<p>Adapted from https://stackoverflow.com/a/9108109/304209.</p>\n\n<p>Args:\n    lst: list to slice.\n    indexes: iterable of 0-based indexes of the list positions to return.</p>\n\n<p>Returns:\n    a new list containing elements of lst on positions specified by indexes.</p>\n", "parameters": ["lst", "indexes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.unit_normal", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "unit_normal", "type": "function", "doc": "<p>Compute unit normal vector of plane defined by points a, b, and c\n:param a: point 1\n:param b: point 2\n:param c: point 3\n:return: vector</p>\n", "parameters": ["a", "b", "c"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.poly_area", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "poly_area", "type": "function", "doc": "<p>Calculate area of a polygon\n:param poly: polygon coordinates\n:return: area</p>\n", "parameters": ["poly"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.WriteEdgesToVTP", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "WriteEdgesToVTP", "type": "function", "doc": "<p>Write a set of edges to a vtp file.\n:param positions: Positions of the nodes.\n:param edges: list of edges\n:param file: file name.\n:return: Nothing</p>\n", "parameters": ["positions", "edges", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.AddArrayToFile", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "AddArrayToFile", "type": "function", "doc": "<p>Add an array to an existing file.\n:param file: existing file\n:param array: array to add\n:param name: name of the array\n:param cell: boolean, add array as cell or point array. True=cell, False=Point\n:return: Nothing</p>\n", "parameters": ["file", "array", "name", "cell"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GeneralFunctions.CreateBoundaryFile", "modulename": "Blood_Flow_1D.GeneralFunctions", "qualname": "CreateBoundaryFile", "type": "function", "doc": "<p>Read a msh file and write a boundary map for the perfusion model.\nFilename = 'boundary_mapper.csv'\n:param file: msh file\n:param folder: output folder\n:return: Nothing</p>\n", "parameters": ["file", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.GenerateBloodflowFiles", "modulename": "Blood_Flow_1D.GenerateBloodflowFiles", "qualname": "", "type": "module", "doc": "<p>1D Blood Flow Simulator\nScript to run a blood flow simulation.\nInput argument is the patient folder with a folder for input files and a folder for modelling files\nThe input folder contains patient data and the modelling file folder contains files for the models\nsuch as the parameters and the surface mesh.\nUsage:\n  BloodFlow.py <patient_folder>\n  BloodFlow.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.GenerateBloodflowFiles.generatebloodflowfiles", "modulename": "Blood_Flow_1D.GenerateBloodflowFiles", "qualname": "generatebloodflowfiles", "type": "function", "doc": "<p>Generate all required files for subsequent simulations and models.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient_folder : str\n    location of patient input files</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>patient : patient object\n    Patient object containing all parameters and data.</p>\n", "parameters": ["patient_folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata", "modulename": "Blood_Flow_1D.Metadata", "qualname": "", "type": "module", "doc": "<p>Classes that store patient and model parameters.</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.Folders", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.Folders.__init__", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders.__init__", "type": "function", "doc": "<p>Object containing paths.</p>\n\n<p>Initiate the object and set up the folder structure.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patientfolder : str\n    Main folder containing all files</p>\n", "parameters": ["self", "patientfolder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.Folders.PatientFolder", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders.PatientFolder", "type": "variable", "doc": "<p>Main folder containg all files</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.Folders.InputFolder", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders.InputFolder", "type": "variable", "doc": "<p>Path to location with input files</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.Folders.ModellingFolder", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders.ModellingFolder", "type": "variable", "doc": "<p>Path to store bf simulation files</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.Folders.DataFilesFolder", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders.DataFilesFolder", "type": "variable", "doc": "<p>Path to folder containing model code</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.Folders.SetPatientFolder", "modulename": "Blood_Flow_1D.Metadata", "qualname": "Folders.SetPatientFolder", "type": "function", "doc": "<p>Update the folder structure</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patientfolder : str\n    Main folder containing all files</p>\n", "parameters": ["self", "patientfolder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.PatientData", "modulename": "Blood_Flow_1D.Metadata", "qualname": "PatientData", "type": "class", "doc": "<p>dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.PatientData.__init__", "modulename": "Blood_Flow_1D.Metadata", "qualname": "PatientData.__init__", "type": "function", "doc": "<p>Dictionary of patient parameters.</p>\n\n<p>Initiate the object with some default parameters</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.PatientData.LoadPatientData", "modulename": "Blood_Flow_1D.Metadata", "qualname": "PatientData.LoadPatientData", "type": "function", "doc": "<p>Load patient parameters and add them to the internal dict.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : str\n    patient parameter txt file</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.PatientData.LoadPatientDataXML", "modulename": "Blood_Flow_1D.Metadata", "qualname": "PatientData.LoadPatientDataXML", "type": "function", "doc": "<p>Load patient parameters and add them to the internal dict.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xml_file : str\n    xml file</p>\n", "parameters": ["self", "xml_file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.PatientData.LoadPatientDataYML", "modulename": "Blood_Flow_1D.Metadata", "qualname": "PatientData.LoadPatientDataYML", "type": "function", "doc": "<p>Load patient parameters and add them to the internal dict.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>yml_file : str\n    yml file</p>\n", "parameters": ["self", "yml_file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.PatientData.WritePatientData", "modulename": "Blood_Flow_1D.Metadata", "qualname": "PatientData.WritePatientData", "type": "function", "doc": "<p>Export patient parameters to txt file.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : str\n     file name</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.ModelParameter", "modulename": "Blood_Flow_1D.Metadata", "qualname": "ModelParameter", "type": "class", "doc": "<p>dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)</p>\n"}, {"fullname": "Blood_Flow_1D.Metadata.ModelParameter.__init__", "modulename": "Blood_Flow_1D.Metadata", "qualname": "ModelParameter.__init__", "type": "function", "doc": "<p>Dictionary of model parameters.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.ModelParameter.LoadModelParameters", "modulename": "Blood_Flow_1D.Metadata", "qualname": "ModelParameter.LoadModelParameters", "type": "function", "doc": "<p>Load model parameters and add them to the internal dict.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : str\n    file containing model parameters</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Metadata.ModelParameter.WriteModelParameters", "modulename": "Blood_Flow_1D.Metadata", "qualname": "ModelParameter.WriteModelParameters", "type": "function", "doc": "<p>Export model parameters to txt file.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>file : str\n    file name</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node", "modulename": "Blood_Flow_1D.Node", "qualname": "", "type": "module", "doc": "<p>Contains the Node object class.</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node", "modulename": "Blood_Flow_1D.Node", "qualname": "Node", "type": "class", "doc": "<p>Node Object</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.__init__", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.Number", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Number", "type": "variable", "doc": "<p>Node Number</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Position", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Position", "type": "variable", "doc": "<p>3-D node position (mm)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Radius", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Radius", "type": "variable", "doc": "<p>Node radius (mm)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Connections", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Connections", "type": "variable", "doc": "<p>Nodes connected to this node</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.R1", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.R1", "type": "variable", "doc": "<p>Resistance 1</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.R2", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.R2", "type": "variable", "doc": "<p>Resistance 2</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.C", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.C", "type": "variable", "doc": "<p>Capacitance</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.YoungsModules", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.YoungsModules", "type": "variable", "doc": "<p>Young's modules (pa)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Type", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Type", "type": "variable", "doc": "<p>node type:0=node, 1=bifurcation, 2=outlet/inlet</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.VesselID", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.VesselID", "type": "variable", "doc": "<p>Vessel ID of parent vessel</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.MajorVesselID", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.MajorVesselID", "type": "variable", "doc": "<p>ID of major cerebral vessel</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.LengthAlongVessel", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.LengthAlongVessel", "type": "variable", "doc": "<p>1-D node position (mm)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Thickness", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Thickness", "type": "variable", "doc": "<p>Vessel wall thickness (mm)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.DirectionVector", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.DirectionVector", "type": "variable", "doc": "<p>Positive direction vector</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Pressure", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Pressure", "type": "variable", "doc": "<p>Pressure (pa)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.Velocity", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.Velocity", "type": "variable", "doc": "<p>Velocity (m/s)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.FlowRate", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.FlowRate", "type": "variable", "doc": "<p>Volume flow rate (mL/s)</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.PressureRadiusEquation", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.PressureRadiusEquation", "type": "variable", "doc": "<p>Function that describes elastic behaviour</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.RefRadius", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.RefRadius", "type": "variable", "doc": "<p>Initial radius</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.RefPressure", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.RefPressure", "type": "variable", "doc": "<p>Initial Pressure</p>\n"}, {"fullname": "Blood_Flow_1D.Node.Node.flux_function", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.flux_function", "type": "function", "doc": "<p>Flux function used in some calculations in the 1-D pulsatile blood flow model.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Area : float\n    Area at the node</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Flux : float\n    flux value</p>\n", "parameters": ["self", "Area"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.chrt_function", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.chrt_function", "type": "function", "doc": "<p>Calculate the difference between forward and backward characteristic.\nInput parameter is a guess for the new area.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Area : float\n    Area at the node.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Result : float\n    Difference between forward and backward characteristic</p>\n", "parameters": ["self", "Area"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetPressureAreaEquation", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetPressureAreaEquation", "type": "function", "doc": "<p>Equation that described the pressure-area relationship at the node.</p>\n\n<p>Sets self.radius</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetPressureAreaEquation_rigid", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetPressureAreaEquation_rigid", "type": "function", "doc": "<p>Equation that described the pressure-area relationship at the node.\nRigid walls, no change in radius)</p>\n\n<p>Sets self.radius</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.UpdateRadius", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.UpdateRadius", "type": "function", "doc": "<p>Update the radius based on the pressure-area relationship.</p>\n\n<p>Sets self.radius</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetNumber", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetNumber", "type": "function", "doc": "<p>Set self.Number</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>number: int\n    New number variable value.</p>\n", "parameters": ["self", "number"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetYoungsModules", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetYoungsModules", "type": "function", "doc": "<p>Set self.YoungsModules</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>modules : float\n    Young's modules</p>\n", "parameters": ["self", "modules"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetLengthAlongVessel", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetLengthAlongVessel", "type": "function", "doc": "<p>Set self.LengthAlongVessel</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>l : float\n    1-D position</p>\n", "parameters": ["self", "l"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetRadius", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetRadius", "type": "function", "doc": "<p>Set self.Radius and update the vessel wall thickness based on the radius.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>r : float\n    New radius variable</p>\n", "parameters": ["self", "r"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetPosition", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetPosition", "type": "function", "doc": "<p>Set self.Position</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pos : iterable object</p>\n", "parameters": ["self", "pos"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetVesselID", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetVesselID", "type": "function", "doc": "<p>Set self.VesselID</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>_id : int\n    Vessel ID</p>\n", "parameters": ["self", "_id"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetType", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetType", "type": "function", "doc": "<p>Set self.Type</p>\n\n<p>0=node, 1=bifurcation, 2=outlet/inlet node.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>type : int\n    type</p>\n", "parameters": ["self", "type"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.CalculateThickness", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.CalculateThickness", "type": "function", "doc": "<p>Calculate the vessel wall thinkness based on the radius.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Thickness : float\n    Wall thickess (mm)</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetMajorVesselID", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetMajorVesselID", "type": "function", "doc": "<p>Set self.MajorVesselID</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>_id : int\n    New major vessel ID</p>\n", "parameters": ["self", "_id"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.GetConnectedVesselIDs", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.GetConnectedVesselIDs", "type": "function", "doc": "<p>Get the vessel ids of the nodes connected to the node.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Connections : list\n    List of vessel IDs of connected nodes</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.GetConnectedMajorVesselIDs", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.GetConnectedMajorVesselIDs", "type": "function", "doc": "<p>Get the major vessel ids of the nodes connected to the node.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Connections : list\n    List of major vessel IDs of connected nodes</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.AddConnection", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.AddConnection", "type": "function", "doc": "<p>Add a node to the set of connected nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : node\n    node to add</p>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.RemoveConnection", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.RemoveConnection", "type": "function", "doc": "<p>Remove a node to the set of connected nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>node : node\n    node to remove</p>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.ResetConnections", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.ResetConnections", "type": "function", "doc": "<p>Clear the list of connected nodes.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetWK", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetWK", "type": "function", "doc": "<p>Set the windkessel parameters: self.R1, self.R2 and self.C.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>r1 : float\n    Resistance 1\nr2 : float\n    Resistance 2\nc :float\n    Capacitance</p>\n", "parameters": ["self", "r1", "r2", "c"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.ResetWK", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.ResetWK", "type": "function", "doc": "<p>Reset the windkessel parameters.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetNodeFromTopLine", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetNodeFromTopLine", "type": "function", "doc": "<p>Update node properties.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>line : list of str\n    Line containing node properties</p>\n", "parameters": ["self", "line"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Node.Node.SetDirectionVector", "modulename": "Blood_Flow_1D.Node", "qualname": "Node.SetDirectionVector", "type": "function", "doc": "<p>Calculate the direction vector of a node.\nOnly valid for internal nodes.</p>\n\n<p>Set self.DirectionVector</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient", "modulename": "Blood_Flow_1D.Patient", "qualname": "", "type": "module", "doc": "<p>Contains the Patient object class.</p>\n"}, {"fullname": "Blood_Flow_1D.Patient.Patient", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Patient.Patient.__init__", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.__init__", "type": "function", "doc": "<p>Initiate the patient object with default values.\n:param folder: path to the main folder.</p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.pool", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.pool", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Patient.Patient.RedefineDirectionByFlowDirection", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.RedefineDirectionByFlowDirection", "type": "function", "doc": "<p>Reverses the order of the nodes in each vessel if the flow inside the vessel is negative.\nThis simple defines the positive flow direction to be the direction of flow.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.RemoveOldSimFiles", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.RemoveOldSimFiles", "type": "function", "doc": "<p>Remove results from previous 1-D blood flow simulations.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ResetModellingFolder", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ResetModellingFolder", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadBFSimFiles", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadBFSimFiles", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadResults", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file", "correct"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.GetMeanResults", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.GetMeanResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ExportMeanResults", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ExportMeanResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadPatientData", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadPatientData", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadClusteringMapping", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadClusteringMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadModelParameters", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadModelParameters", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadSegmentedVessels", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadSegmentedVessels", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "CoWFile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Load1DAnatomy", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Load1DAnatomy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Load3DTopFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Load3DTopFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadPositions", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadPositions", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ClusteringByRegion", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ClusteringByRegion", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dualgraph", "method"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.SetFolder", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.SetFolder", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.TopologyToVTP", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.TopologyToVTP", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.SaveVesselAtlas", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.SaveVesselAtlas", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadVTPFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadVTPFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "vtpfile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteClusteringMapping", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteClusteringMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteModelParameters", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteModelParameters", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.CalculateMaximumTimestep", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.CalculateMaximumTimestep", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.CalculateDistanceFromTheHeart", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.CalculateDistanceFromTheHeart", "type": "function", "doc": "<p>Returns the distance from the heart in the shortest sense bansed on Dijkstra's distance.\nDirection is determined by the positive pressure direction.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.CalculateTimedelayFromTheHeart", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.CalculateTimedelayFromTheHeart", "type": "function", "doc": "<p>Returns the timedelay from the heart in the shortest sense bansed on Dijkstra's distance.\nDirection is determined by the positive pressure direction.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.UpdateNodeType", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.UpdateNodeType", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.CorrectforDirectionVectorOutlets", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.CorrectforDirectionVectorOutlets", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.CerebellumBrainstemMapping", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.CerebellumBrainstemMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.calculate_wk_parameters", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.calculate_wk_parameters", "type": "function", "doc": "<p>Calculate the windkessel parameters for the outlets of the network.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.calculate_wk_parameters_evenly", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.calculate_wk_parameters_evenly", "type": "function", "doc": "<p>Calculate the windkessel parameters for the outlets of the network.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteSimFiles", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteSimFiles", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ExportSurface", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ExportSurface", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.SelectPatient", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.SelectPatient", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.SelectDonorNetwork", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.SelectDonorNetwork", "type": "function", "doc": "<p>Select a network from the Brava set to extend the patient network.\nFor now, the donor is randomly selected from the folder.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.UpdateModelParameters", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.UpdateModelParameters", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteFlowProfilesAlastruey2007", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteFlowProfilesAlastruey2007", "type": "function", "doc": "<p>Take patient parameters and generate flow profiles.\nAssumption is that the two inlets with the largest radius are the carotid arteries.\nFlowrate given here are ml/s</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteFlowProfiles", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteFlowProfiles", "type": "function", "doc": "<p>Take patient parameters and generate flow profiles.\nAssumption is that the two inlets with the largest radius are the carotid arteries.\nFlowrate given here are ml/s</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.VesselToMeshAllignmentSides", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.VesselToMeshAllignmentSides", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ApplyTransformation", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ApplyTransformation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "matrix"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.FindCouplingPoints", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.FindCouplingPoints", "type": "function", "doc": "<p>Map the outlets to the nearest point on the surface.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.RemoveCoWOutletsFromPerfusion", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.RemoveCoWOutletsFromPerfusion", "type": "function", "doc": "<p>The donor networks have outlets that do not get transferred.\nThese need to be removed.\nIf the coupling point node does not have a number, remove it from the list.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteCouplingPointsFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteCouplingPointsFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteClotFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteClotFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "name"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteTopologyFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteTopologyFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteParFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteParFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteRunFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteRunFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.GenerateTreesAtCps", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.GenerateTreesAtCps", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "cutoff"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.GenerateTrees", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.GenerateTrees", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "cutoff"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.getTotalEndsofTrees", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.getTotalEndsofTrees", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.PerfusionEndsNumber", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.PerfusionEndsNumber", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.GenerateTree", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.GenerateTree", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node", "cutoff"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.TreesToTopology", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.TreesToTopology", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.AddTreesToTop", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.AddTreesToTop", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.TreeEndsToEndNodes", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.TreeEndsToEndNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadClusters", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadClusters", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadSurfaceMapping", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadSurfaceMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.DistributeFlowVertex", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.DistributeFlowVertex", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.GetMeanFlowRates", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.GetMeanFlowRates", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.DistributeFlowTriangles", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.DistributeFlowTriangles", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteTimeseriesVessels", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteTimeseriesVessels", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ImportClotNodeFile", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ImportClotNodeFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ImportClots", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ImportClots", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ShowResults", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ShowResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.MappingSixMajorArteries", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.MappingSixMajorArteries", "type": "function", "doc": "<p>Follow the major cerebreal arteries upstream and return the outlets.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ExportDualClustering", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ExportDualClustering", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "primal", "dual"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ExportTriangleFlowData", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ExportTriangleFlowData", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.MajorArteriesToPialSurfaceNN", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.MajorArteriesToPialSurfaceNN", "type": "function", "doc": "<p>Map surface to to nearest node, colour based on nearest vessel.\nOutput is nearest major vessel ID.\nNote that the left and right halves of the brain are taken into account\n:param graph: The surface graph to map with the major vessel id of the nearest vessel\n:return: graph.MajorVesselID is updated to the mapping.</p>\n", "parameters": ["self", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.MajorArteriesToPialSurfaceOutlets", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.MajorArteriesToPialSurfaceOutlets", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.WriteRegionMapping", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.WriteRegionMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.LoadRegionMapping", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.LoadRegionMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Initiate1DSteadyStateModel", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Initiate1DSteadyStateModel", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Solve1DSteadyState", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Solve1DSteadyState", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "clotactive", "PressureInlets", "coarseCollaterals", "FlowRateOutlets", "frictionconstant"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Solve1DSteadyStateNonLinear", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Solve1DSteadyStateNonLinear", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.UpdateOutletResistanceToPialSurface", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.UpdateOutletResistanceToPialSurface", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "PialSurfacePressure"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.UpdatePressureCouplingPoints", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.UpdatePressureCouplingPoints", "type": "function", "doc": "<p>Update the pressure at the coupling points to the perfusion model.\n:param pressures: (iterable or number) Pressure in pa to be assigned at the coupling point.\nOrder of the pressures given should be in the same order as the coupling points.\nCoupling point index is equal to the cluster id.\n:return: Nothing</p>\n", "parameters": ["self", "pressures"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.UpdateFlowRateCouplingPoints", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.UpdateFlowRateCouplingPoints", "type": "function", "doc": "<p>Update the flowrate at the coupling points to the perfusion model.\n:param flowrates: (iterable or number) Flow rate in mL/s to be assigned at the coupling point.\nOrder of the flowrate given should be in the same order as the coupling points.\nCoupling point index is equal to the cluster id.\n:return: Nothing</p>\n", "parameters": ["self", "flowrates"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Run1DSteadyStateModel", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Run1DSteadyStateModel", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "model", "tol", "clotactive", "PressureInlets", "coarseCollaterals", "FlowRateOutlets", "frictionconstant", "scale_resistance"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Results1DSteadyStateModel", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Results1DSteadyStateModel", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.Export1DSteadyClusterFlowRate", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.Export1DSteadyClusterFlowRate", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Patient.Patient.ExportClotBFValues", "modulename": "Blood_Flow_1D.Patient", "qualname": "Patient.ExportClotBFValues", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "", "type": "module", "doc": "<p>Contains the perfusion,  surface and coupling points object classes.</p>\n"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.__init__", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.__init__", "type": "function", "doc": "<p>Initiate object</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.CalculateScipyGraph", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.CalculateScipyGraph", "type": "function", "doc": "<p>Convert networkx graph to a scipy graph.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.IdentifyNeighbouringRegions", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.IdentifyNeighbouringRegions", "type": "function", "doc": "<p>Identify touching regions of the surface\nOutput list of sets where the index of the set refers to the region,\n and the set contains the index of the neighbouring regions.</p>\n\n<h2 id=\"returns-sets-selfconnected_regions\">Returns:  sets self.connected_regions</h2>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.GetSurfaceRegion", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.GetSurfaceRegion", "type": "function", "doc": "<p>Get part of the surface.\n:param regionids: region id of the part to extract\n:return: Triangles, positions</p>\n", "parameters": ["self", "regionids"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.CalculateDijkstraMatrix", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.CalculateDijkstraMatrix", "type": "function", "doc": "<p>Warning, this can require TBs of space.\nSize depends on the size of the surface,\nCalculate the dijkstra distance of the surface\n:return: distance matrix</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.FindNearestSurfaceNode", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.FindNearestSurfaceNode", "type": "function", "doc": "<p>Map the outlets to the nearest point on the surface.\nA threshold can be used to remove outlets far away.\n:param couplingpoints: points to map\n:param threshold: threshold\n:return: Nothing</p>\n", "parameters": ["self", "couplingpoints", "threshold"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.ExportTriangleColour", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.ExportTriangleColour", "type": "function", "doc": "<p>Export surface mapping.\nFile contains the triangle number, cluster ID and area of the triangle.\n:param folder: output folder\n:return: Nothing</p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.CalculateAreas", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.CalculateAreas", "type": "function", "doc": "<p>Compute the area of every triangle of the surface.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.DefineSides", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.DefineSides", "type": "function", "doc": "<p>Set the SideInfo variable based on the x-coordinate.\n1=right, -1=left.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.define_sides_plane", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.define_sides_plane", "type": "function", "doc": "<p>Given plane defined as a point on the plane and the normal direction of the plane, determine below and above regions as left/right.\n1=right, -1=left.\n:return: Nothing</p>\n", "parameters": ["self", "point", "normal"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.WeightedSampling", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.WeightedSampling", "type": "function", "doc": "<p>Return a weighted sampling of the surface triangles without replacement.\n:param region: region to sample.\n:param n: number of returned sampled.\n:return: list of sampled.</p>\n", "parameters": ["self", "region", "n"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.CalculateDistanceMatRegion", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.CalculateDistanceMatRegion", "type": "function", "doc": "<p>Calculate the distance matrix between two set of points.\n:param method: Distance method: euclidean or dijkstra\n:param roots: First set\n:param surfacepoints: second set of points\n:return: distance matrix</p>\n", "parameters": ["self", "method", "roots", "surfacepoints"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.ToGraph", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.ToGraph", "type": "function", "doc": "<p>Convert the surface to a networkx graph. Edgeweight is the distance between nodes.\n:return: Nothing</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.LoadSurface", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.LoadSurface", "type": "function", "doc": "<p>Load a surface.\n:param file: surface file\n:return: Nothing</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.LoadSurfaceMSH", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.LoadSurfaceMSH", "type": "function", "doc": "<p>Load a msh surface file.\n:param file: msh file\n:return: Nothing</p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.GetTriangleCentroids", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.GetTriangleCentroids", "type": "function", "doc": "<p>Calculate the centroid of every triangle of the surface.\n:return: list of centroid coordinates.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.GetCentersGraph", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.GetCentersGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "method"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.GraphToVTP", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.GraphToVTP", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Surface.GraphEdgesToVTP", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Surface.GraphEdgesToVTP", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.__init__", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.AddCouplingPoint", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.AddCouplingPoint", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "couplingpoint"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.RemoveCouplingPoint", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.RemoveCouplingPoint", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "couplingpoint"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.LoadPrimalGraph", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.LoadPrimalGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.SetClusterIDs", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.SetClusterIDs", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.ClusterArea", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.ClusterArea", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.FindNearestSurfaceNodeSides", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.FindNearestSurfaceNodeSides", "type": "function", "doc": "<p>Map the outlets to the nearest point on the surface.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.FindNearestSurfaceNodeVEASL", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.FindNearestSurfaceNodeVEASL", "type": "function", "doc": "<p>Map the outlets to the nearest point on the surface.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.OutputClusteringSteps", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.OutputClusteringSteps", "type": "function", "doc": "<p>Output the clustering steps\n:param file: File to write the clustering of the surface to, per iteration\n:param rootsfile: File to write the path of the root of each cluster to.\n:return: Nothing</p>\n", "parameters": ["self", "file", "rootsfile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.WriteClusteringMapping", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.WriteClusteringMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.UpdateMappedRegionsFlowdata", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.UpdateMappedRegionsFlowdata", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.SetDualGraph", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.SetDualGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "method"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.MapDualGraphToPrimalGraph", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.MapDualGraphToPrimalGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.SquareLatticeCP", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.SquareLatticeCP", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "clusters"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.SquareLattice", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.SquareLattice", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "graph", "nn"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.ExportSurface", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.ExportSurface", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.ExportSurfacePoints", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.ExportSurfacePoints", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file", "graph"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.Clustering", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.Clustering", "type": "function", "doc": "<p>:param dualgraph:\n:param distancemat:\n:param method:\n:param fractiontriangles:\n:param debug:\n:param maxiter:\n:return:</p>\n", "parameters": ["self", "dualgraph", "distancemat", "method", "fractiontriangles", "debug", "maxiter", "useregion"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.ClusteringByRegion", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.ClusteringByRegion", "type": "function", "doc": "<p>Algorithm to estimate perfusion territories.\n:param dualgraph: Graph to use for the clustering. Clustering happens with the vertices of the graph, clustering of triangles requires the dual graph.\n:param method: Default option: Dijkstra, Other option: 'euclidean'\n:param fractiontriangles: Sets the fraction of triangles to use for the initial clustering. Mainly for performance reasons.\n:param debug: Default:False. True sets the number of points per cluster to one. Use this to get a quickyclustering to the nearst outlet.\n:return: Clustering result is stored under dualgraph.NodeColour. See MapDualGraphToPrimalGraph() for mapping back to the primal graph.</p>\n", "parameters": ["self", "dualgraph", "distancemat", "method", "fractiontriangles", "debug", "maxiter", "useregion", "scaling_factor"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.ClusteringMetis", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.ClusteringMetis", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "dualgraph", "distancemat", "maxiter", "useregion"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.Perfusion.RemapMajorRegions", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "Perfusion.RemapMajorRegions", "type": "function", "doc": "<p>Remap wrongly mapped regions to the nearst major region.\n:return: Updated mappings</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Perfusion.CouplingPoint", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "CouplingPoint", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Perfusion.CouplingPoint.__init__", "modulename": "Blood_Flow_1D.Perfusion", "qualname": "CouplingPoint.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Permeable_Clots", "modulename": "Blood_Flow_1D.Permeable_Clots", "qualname": "", "type": "module", "doc": "<p>Simulate various permeable clots and colleterals</p>\n\n<p>Usage:\n  ContrastModel.py <number>\n  ContrastModel.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.Permeable_Clots.permeability_simulation", "modulename": "Blood_Flow_1D.Permeable_Clots", "qualname": "permeability_simulation", "type": "function", "doc": "<p>Run the 1D model with data from patient_folder</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>iterations\ncontrast_sim_time : simulation time\npatient_folder : str\n    Patient folder location</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["patient_folder", "iterations", "contrast_sim_time"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Permeable_Clots.splitclotvessel", "modulename": "Blood_Flow_1D.Permeable_Clots", "qualname": "splitclotvessel", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Permeable_Clots.write_time_series", "modulename": "Blood_Flow_1D.Permeable_Clots", "qualname": "write_time_series", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Remesh", "modulename": "Blood_Flow_1D.Remesh", "qualname": "", "type": "module", "doc": "<p>Script to remesh a surface file with a set number of uniform triangles.</p>\n"}, {"fullname": "Blood_Flow_1D.Remesh.remesh", "modulename": "Blood_Flow_1D.Remesh", "qualname": "remesh", "type": "function", "doc": "<p>Remesh a surface mesh using using voronoi clustering. Source and module at https://pypi.org/project/pyacvd/</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>surfacefile : str\n    Surfacefile to be remeshed to a uniform triangulation.\nnumbertriangles : int\n    Number of triangles that the surface will have after the remeshing. Default:40000\noutput : str\n    output file name</p>\n", "parameters": ["surfacefile", "numbertriangles", "output"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Remesh.MapMeshtoMSH", "modulename": "Blood_Flow_1D.Remesh", "qualname": "MapMeshtoMSH", "type": "function", "doc": "<p>Apply the mapping on one surface to another surface.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>filevtp : str\n    The remeshed surface file, see the remesh function.\nfilemsh : str\n    The file containing the VEASL mapping.\noutput : str\n    Filename of the resulting file.</p>\n", "parameters": ["filevtp", "filemsh", "output"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results", "modulename": "Blood_Flow_1D.Results", "qualname": "", "type": "module", "doc": "<p>Contains the Results object class.</p>\n"}, {"fullname": "Blood_Flow_1D.Results.Results", "modulename": "Blood_Flow_1D.Results", "qualname": "Results", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Results.Results.__init__", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.ClearResults", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.ClearResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.addtimepoint", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.addtimepoint", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "time"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.LoadResults", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.LoadResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "datafile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.ExportResults", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.ExportResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "datafile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.get_results", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.get_results", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.SplitHeartbeats", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.SplitHeartbeats", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.CorrectForDirectionEnds", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.CorrectForDirectionEnds", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ids"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.CalculateMeanVessel", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.CalculateMeanVessel", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ids"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.GetMeanResults", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.GetMeanResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "vessels"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.ExportMeanResults", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.ExportMeanResults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.SimTime", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.SimTime", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.CalculateVelocity", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.CalculateVelocity", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.CalculateMeanResultsPerNode", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.CalculateMeanResultsPerNode", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.PlotPIRadius", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.PlotPIRadius", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "figname", "figuredpi"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.PlotPIRadiusVessel", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.PlotPIRadiusVessel", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "figname", "figuredpi"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.plotallprofiles", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.plotallprofiles", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ids", "name", "figuredpi", "legend"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.PlotDistancePI", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.PlotDistancePI", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "figname", "figuredpi"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.AddResultsPerNodeToFile", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.AddResultsPerNodeToFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.Results.AddResultsPerVesselToFile", "modulename": "Blood_Flow_1D.Results", "qualname": "Results.AddResultsPerVesselToFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.TimePoint", "modulename": "Blood_Flow_1D.Results", "qualname": "TimePoint", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Results.TimePoint.__init__", "modulename": "Blood_Flow_1D.Results", "qualname": "TimePoint.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "time"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.TimePoint.addresults", "modulename": "Blood_Flow_1D.Results", "qualname": "TimePoint.addresults", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "results"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow", "type": "class", "doc": "<p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p>\n"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.__init__", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.updateVessel", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.updateVessel", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.file_changed", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.file_changed", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.updatefig", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.updatefig", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.savefig", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.savefig", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "figuredpi"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.PressureTommhg", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.PressureTommhg", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ax2"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Results.ResultsWindow.exit", "modulename": "Blood_Flow_1D.Results", "qualname": "ResultsWindow.exit", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis", "modulename": "Blood_Flow_1D.Thrombolysis", "qualname": "", "type": "module", "doc": "<p>Permeability Simulator</p>\n\n<p>Script to run a simulation of the 1D BF model with changing permeability.\nInput argument is the patient folder with a folder for input files and a folder for modelling files\nThe input folder contains patient data.\nThe modelling file folder contains files for the models such as the parameters and the surface mesh.</p>\n\n<p>Usage:\n  tavernaBloodFlow.py <patient_folder>\n  tavernaBloodFlow.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.Thrombolysis.permeability_simulation", "modulename": "Blood_Flow_1D.Thrombolysis", "qualname": "permeability_simulation", "type": "function", "doc": "<p>Run the 1D model with data from patient_folder</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient_folder : str\n    Patient folder location</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["patient_folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis.contrast_matrix", "modulename": "Blood_Flow_1D.Thrombolysis", "qualname": "contrast_matrix", "type": "function", "doc": "<p></p>\n", "parameters": ["patient", "dt"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis.splitclotvessel", "modulename": "Blood_Flow_1D.Thrombolysis", "qualname": "splitclotvessel", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis.write_time_series", "modulename": "Blood_Flow_1D.Thrombolysis", "qualname": "write_time_series", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis1D", "modulename": "Blood_Flow_1D.Thrombolysis1D", "qualname": "", "type": "module", "doc": "<p>Thrombolysis Simulator</p>\n\n<p>Script to run a simulation of the 1D BF model with changing clot length.\nInput argument is the patient folder with a folder for input files and a folder for modelling files\nThe input folder contains patient data.\nThe modelling file folder contains files for the models such as the parameters and the surface mesh.</p>\n\n<p>Usage:\n  tavernaBloodFlow.py <patient_folder>\n  tavernaBloodFlow.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.Thrombolysis1D.change_clot_length", "modulename": "Blood_Flow_1D.Thrombolysis1D", "qualname": "change_clot_length", "type": "function", "doc": "<p></p>\n", "parameters": ["time", "tpa_concentration", "dp", "c_fibrin"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis1D.tpa_concentration_function", "modulename": "Blood_Flow_1D.Thrombolysis1D", "qualname": "tpa_concentration_function", "type": "function", "doc": "<p></p>\n", "parameters": ["time"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Thrombolysis1D.permeability_simulation", "modulename": "Blood_Flow_1D.Thrombolysis1D", "qualname": "permeability_simulation", "type": "function", "doc": "<p>Run the 1D model with data from patient_folder</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>patient_folder : str\n    Patient folder location</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["patient_folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology", "modulename": "Blood_Flow_1D.Topology", "qualname": "", "type": "module", "doc": "<p>Contains the Topology object class.</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Topology", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Topology.__init__", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.MapbifurcationstoVessels", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.MapbifurcationstoVessels", "type": "function", "doc": "<p>For each bifurcation in topology (self.BifurcationNodes),\nthe VesselConnections is created with the connected vessels.\n:return: None.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.MapNodesToVesselID", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.MapNodesToVesselID", "type": "function", "doc": "<p>Create a dictionary of nodes to major vessel ID\n:return: dict with keys the nodes and values their major vessel ID.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.NodeVesselDict", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.NodeVesselDict", "type": "function", "doc": "<p>Create a dict that maps nodes to the vessel.\nSets self.NodeDict\n:return: dictionary of nodes to vessels</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.VesselGraph", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.VesselGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetVesselNameFromNode", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetVesselNameFromNode", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.UpdateNodeType", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.UpdateNodeType", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.UpdateM2Names", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.UpdateM2Names", "type": "function", "doc": "<p>Update the vessel names of the m2 vessels.\nSmaller branch:inferior branch\nLarger branch: superior branch</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.UpdateVesselAtlas", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.UpdateVesselAtlas", "type": "function", "doc": "<p>Create an dictionary keyed to vessel name and vessel id.\nValue returned from the dictionary is the vessel.\n:return: None, self.VesselAtlas is updated.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.UpdateTopology", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.UpdateTopology", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.WriteNodesCSV", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.WriteNodesCSV", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.WriteVesselCSV", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.WriteVesselCSV", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.BifurcationDict", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.BifurcationDict", "type": "function", "doc": "<p>Create a dictionary of the bifurcation nodes.\nKeys are the nodes of the system and return value is the linked bifurcation node\n:return: dict{node:bifnode}</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.UpdateNumbers", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.UpdateNumbers", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SetThickness", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SetThickness", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.CheckConnectivity", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.CheckConnectivity", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SaveVesselAtlas", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SaveVesselAtlas", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadSegmentedVessels_old", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadSegmentedVessels_old", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "inputfolder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadSegmentedVessels", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadSegmentedVessels", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "inputfolder", "CoWFile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadBFSimFiles", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadBFSimFiles", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "folder"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadTopFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadTopFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadParFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadParFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadRunFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadRunFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadClotFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadClotFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadVTPFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadVTPFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "vtpfile"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.Load1DAnatomy", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.Load1DAnatomy", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.NumberNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.NumberNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetDownstreamVessels", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetDownstreamVessels", "type": "function", "doc": "<p>Get upstream vessels and bifurcation nodes.\nNote that this follows the positive directon of the vessels.\nIf vessels are excluded that should be included, check the direction of those vessels.</p>\n\n<p>The code finds the relevent bifucations and then checks which vessels are connected.</p>\n", "parameters": ["self", "inputvessel"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.ReorderGens", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.ReorderGens", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "gens"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.DownStreamResistance", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.DownStreamResistance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "inputvessel", "visc", "density"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.sumresvessels", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.sumresvessels", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "upstream", "downstream"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.RedefineDirection", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.RedefineDirection", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetVesselsFromType", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetVesselsFromType", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "inputtype"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.ReadNodesFromTopFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.ReadNodesFromTopFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.Read3DNodesFromTopFile", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.Read3DNodesFromTopFile", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.LoadVesselAtlas", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.LoadVesselAtlas", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "file"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SetInletNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SetInletNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "inlets"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SetOutletNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SetOutletNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "outlets"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SetBifurcationNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SetBifurcationNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "bifurcationnodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.FindBifurcationNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.FindBifurcationNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.FindOutletNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.FindOutletNodes", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.FindlargestInlets", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.FindlargestInlets", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "InletNumber"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.ApplyTransformation", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.ApplyTransformation", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "matrix"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.AnatomyToVessels", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.AnatomyToVessels", "type": "function", "doc": "<p>Get vessels from topology data\nstart at an end point\nget the neighbour, if connection of neighbour is 2 then get next neighbour and repeat.\nIf connection is 1, stop. If connection is more than 2, stop and start new vessel.\nrepeat for every end point, keep track of nodes that are already assigned to a vesse (except bif nodes)\nbifurcation nodes are nodes with more than 2 connections</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.removebifurcation", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.removebifurcation", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.TopologyToVTP", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.TopologyToVTP", "type": "function", "doc": "<p>Write the network to a .vtp file.\nThis only works with 3-D coordinates.</p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetMapping", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetMapping", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.CalculateMaximumTimestep", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.CalculateMaximumTimestep", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "density"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetAdjacencyMatrix", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetAdjacencyMatrix", "type": "function", "doc": "<p>Get the adjacency matrix of the network</p>\n\n<p>:return: scipy sparse matrix, nodes in order</p>\n", "parameters": ["self", "bloodvisc"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetAdjacencyMatrix2", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetAdjacencyMatrix2", "type": "function", "doc": "<p>Get the adjacency matrix of the network</p>\n\n<p>:return: scipy sparse matrix, nodes in order</p>\n", "parameters": ["self", "bloodvisc"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.GetVesselResistance", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.GetVesselResistance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "bloodvisc"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SegmentConductance", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SegmentConductance", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node1", "node2", "bloodvisc", "frictionconstant"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.TopologyToGraph", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.TopologyToGraph", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.Get1DsteadyNetwork", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.Get1DsteadyNetwork", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "bloodvisc", "clotactive", "PressureInlets", "coarseCollaterals", "FlowRateOutlets", "frictionconstant"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.addCollateralsToTopology", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.addCollateralsToTopology", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.SteadyStateNonLinear", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.SteadyStateNonLinear", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "bloodvisc", "density", "clotactive", "PressureInlets"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Topology.nonlinearmodel", "modulename": "Blood_Flow_1D.Topology", "qualname": "Topology.nonlinearmodel", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "bloodvisc", "density"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Tree", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree", "type": "class", "doc": "<p>Object that defines the bifurcating trees.</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.__init__", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Tree.NumberOfGenerations", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.NumberOfGenerations", "type": "variable", "doc": "<p>Number of vessel generations</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.Direction", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.Direction", "type": "variable", "doc": "<p>Direction of the bifurcating tree</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.InitialNode", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.InitialNode", "type": "variable", "doc": "<p>Root node of the tree</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.StartingTreeNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.StartingTreeNodes", "type": "variable", "doc": "<p>First node of the tree (bifurcation node)</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.EndNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.EndNodes", "type": "variable", "doc": "<p>Outlets of the tree</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.Nodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.Nodes", "type": "variable", "doc": "<p>All nodes</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.Vessels", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.Vessels", "type": "variable", "doc": "<p>Tree vessels</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.BifurcationNodes", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.BifurcationNodes", "type": "variable", "doc": "<p>Bifurcation nodes</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.LengthRadiusRatio", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.LengthRadiusRatio", "type": "variable", "doc": "<p>Length to radius ratio</p>\n"}, {"fullname": "Blood_Flow_1D.Topology.Tree.GenerateTree", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.GenerateTree", "type": "function", "doc": "<p>Generate a bifurcating tree at the endnodes of the tree.\nVessels are added until a cut-off radius.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>cutoff : float\n    Cut-off radius to stop the adding of vessels at the end of the tree.</p>\n", "parameters": ["self", "cutoff"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Topology.Tree.ConnectTree", "modulename": "Blood_Flow_1D.Topology", "qualname": "Tree.ConnectTree", "type": "function", "doc": "<p>Add the neccessary connections between the inital node and the first node of the tree.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel", "modulename": "Blood_Flow_1D.Vessel", "qualname": "", "type": "module", "doc": "<p>Contains the Vessel object class.</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel", "type": "class", "doc": "<p>Vessel Object that stores nodes and varrious parameters.</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.__init__", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Nodes", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Nodes", "type": "variable", "doc": "<p>Vessel nodes</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.NumberOfNodes", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.NumberOfNodes", "type": "variable", "doc": "<p>Number of nodes</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Length", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Length", "type": "variable", "doc": "<p>Vessel length</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.MeanRadius", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.MeanRadius", "type": "variable", "doc": "<p>Mean vessel radius</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.MeanThickness", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.MeanThickness", "type": "variable", "doc": "<p>Mean vessel thickness</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.GridSize", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.GridSize", "type": "variable", "doc": "<p>Grid size</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Name", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Name", "type": "variable", "doc": "<p>Vessel name</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.ID", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.ID", "type": "variable", "doc": "<p>Vessel ID</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.MajorVesselID", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.MajorVesselID", "type": "variable", "doc": "<p>Major vessel ID</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.YoungsModules", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.YoungsModules", "type": "variable", "doc": "<p>Young's modules (pa)</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Resistance", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Resistance", "type": "variable", "doc": "<p>Vessel resistance</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Compliance", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Compliance", "type": "variable", "doc": "<p>Vessel compliance</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.InterpolationFunctions", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.InterpolationFunctions", "type": "variable", "doc": "<p>Interpolation functions of position and radius</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.GenerationNumber", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.GenerationNumber", "type": "variable", "doc": "<p>Generation number of the vessel</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Type", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Type", "type": "variable", "doc": "<p>Vessel type</p>\n"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.GetDistalBifurcation", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.GetDistalBifurcation", "type": "function", "doc": "<p>Bifurcation node at the distal end of the vessel.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Node : node or None\n    Bifurcation node if it exists</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.GetProximalBifurcation", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.GetProximalBifurcation", "type": "function", "doc": "<p>Bifurcation node at the proximal end of the vessel.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Node : node or None\n    Bifurcation node if it exists</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.GetEndNodes", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.GetEndNodes", "type": "function", "doc": "<p>Return list of the proximal and distal bifurcation nodes.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>nodelist : list\n    List of proximal and distal bifurcation nodes if they exist.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.UpdateNodeVesselID", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.UpdateNodeVesselID", "type": "function", "doc": "<p>Update all nodes of the vessel to the vessel IDs of the vessel.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.UpdateNodeNumber", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.UpdateNodeNumber", "type": "function", "doc": "<p>Update the number of nodes that belong to this vessel.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetType", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetType", "type": "function", "doc": "<p>Set the type of the vessel.\n0=default: not defined, 1=1D network, 2=Brava, 3=Tree, 4=pialnetwork, 5=collateral in pial network</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>type : int\n    type to set self.Type</p>\n", "parameters": ["self", "type"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetID", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetID", "type": "function", "doc": "<p>Set the ID of the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>idnumber : int\n    Value to set self.ID</p>\n", "parameters": ["self", "idnumber"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetName", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetName", "type": "function", "doc": "<p>Set the name of the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>name : str\n    Value to set self.Name</p>\n", "parameters": ["self", "name"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.UpdateNodeDirectionVectors", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.UpdateNodeDirectionVectors", "type": "function", "doc": "<p>Calculate the direction vectors for every node of the vessel.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetNodes", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetNodes", "type": "function", "doc": "<p>Set nodes of this vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>nodes : list\n    list of nodes</p>\n", "parameters": ["self", "nodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetLength", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetLength", "type": "function", "doc": "<p>Set the length of the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>length : float\n    Value to set self.Length</p>\n", "parameters": ["self", "length"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetMeanRadius", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetMeanRadius", "type": "function", "doc": "<p>Set the mean radius of the vessel and calculate the mean thickness using the thickness equation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rad : float\n    Radius value</p>\n", "parameters": ["self", "rad"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetMeanThickness", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetMeanThickness", "type": "function", "doc": "<p>Set the mean thickness of the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>h : float\n    Value to set self.MeanThickness</p>\n", "parameters": ["self", "h"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetGridSize", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetGridSize", "type": "function", "doc": "<p>Set the distance between nodes of the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>gridsize : float\n    Distance value</p>\n", "parameters": ["self", "gridsize"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.SetMajorVesselID", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.SetMajorVesselID", "type": "function", "doc": "<p>Set the major vessel id of the vessel and update the major vessel id of the nodes.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>majorid : int\n    Major vessel id value</p>\n", "parameters": ["self", "majorid"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.ScaleRadius", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.ScaleRadius", "type": "function", "doc": "<p>Scale the radius of the vessel and the nodes.\nAlso calculates new vessel thicknesses.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>r : float\n    scaling factor</p>\n", "parameters": ["self", "r"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.UpdateVessel", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.UpdateVessel", "type": "function", "doc": "<p>Update the vessel ids of the vessel nodes and the number of nodes.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.CalculateMeanRadius", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.CalculateMeanRadius", "type": "function", "doc": "<p>Calculate the mean radius of the vessel from the radii of the nodes.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>MeanRadius : float\n    Mean radius of the vessel</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.CalculateMeanThickness", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.CalculateMeanThickness", "type": "function", "doc": "<p>Calculate the mean thinkness of the vessel from the thinkness of the nodes.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.VesselResistance", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.VesselResistance", "type": "function", "doc": "<p>Calulate the resistance of the vessel based on a blunt profile.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>bloodvisc : float\n    blood viscocity value</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>R : float\n    Resistance of the vessel</p>\n", "parameters": ["self", "bloodvisc"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.VesselCompliance", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.VesselCompliance", "type": "function", "doc": "<p>Calculate the compliance of the vessel</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>C1D : float\n    Compliance of the vessel</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.GenerateVessel", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.GenerateVessel", "type": "function", "doc": "<p>Generate vessel nodes. The vessel is modelled as an elastic tube with a taper.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>length : float\n    total length of the vessel\ninletradius : float\n    proximal radius\noutletradius : float\n    distal radius\nElastic : float\n    Young's modules</p>\n", "parameters": ["self", "length", "inletradius", "outletradius", "Elastic"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.InterpolateVessel3Dto1D", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.InterpolateVessel3Dto1D", "type": "function", "doc": "<p>Interpolate the vessels in 3D and update each node position along the vessel (1D).</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.CreateInterpolationFunctions", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.CreateInterpolationFunctions", "type": "function", "doc": "<p>Create interpolation functions based on the 3-D coordinates of the current nodes.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.UpdateInterpolationFunctions", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.UpdateInterpolationFunctions", "type": "function", "doc": "<p>Update the interpolation functions of the vessel.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.Interpolate3D", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.Interpolate3D", "type": "function", "doc": "<p>Using the interpolation functions of the vessel, interpolate the 3-D coordinates and radii along the center line.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>lengthalongvessel : float\n    length along the center line.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>functions : list\n    list of 3-D coordinates and radius</p>\n", "parameters": ["self", "lengthalongvessel"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.CalculateMaxWaveSpeed", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.CalculateMaxWaveSpeed", "type": "function", "doc": "<p>Calculate the maximum wave velocity in the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>density : float\n    fluid density</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>maxwavespeed : float\n    maximum wave velocity</p>\n", "parameters": ["self", "density"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.UpdateResolution", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.UpdateResolution", "type": "function", "doc": "<p>Update the nodes of the vessel by changing the number of nodes.\nPositions and radii are interpolated from the interpolation functions of the vessel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>numbernodes : int\n    new number of nodes</p>\n", "parameters": ["self", "numbernodes"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.Vessel.Vessel.add_node_interp_length", "modulename": "Blood_Flow_1D.Vessel", "qualname": "Vessel.add_node_interp_length", "type": "function", "doc": "<p>Add node to the vessel at the chosen length position.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>lengthalongvessel: Location where along the vessel to add a node</p>\n\n<h2 id=\"returns\">Returns</h2>\n", "parameters": ["self", "lengthalongvessel"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.docopt", "modulename": "Blood_Flow_1D.docopt", "qualname": "", "type": "module", "doc": "<p>Pythonic command-line interface parser that will make you smile.</p>\n\n<ul>\n<li>http://docopt.org</li>\n<li>Repository and issue-tracker: https://github.com/docopt/docopt</li>\n<li>Licensed under terms of MIT license (see LICENSE-MIT)</li>\n<li>Copyright (c) 2013 Vladimir Keleshev, vladimir@keleshev.com</li>\n</ul>\n"}, {"fullname": "Blood_Flow_1D.docopt.docopt", "modulename": "Blood_Flow_1D.docopt", "qualname": "docopt", "type": "function", "doc": "<p>Parse <code>argv</code> based on command-line interface described in <code>doc</code>.</p>\n\n<p><code>docopt</code> creates your command-line interface based on its\ndescription that you pass as <code>doc</code>. Such description can contain\n--options, <positional-argument>, commands, which could be\n[optional], (required), (mutually | exclusive) or repeated...</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>doc : str\n    Description of your command-line interface.\nargv : list of str, optional\n    Argument vector to be parsed. sys.argv[1:] is used if not\n    provided.\nhelp : bool (default: True)\n    Set to False to disable automatic help on -h or --help\n    options.\nversion : any object\n    If passed, the object will be printed if --version is in\n    <code>argv</code>.\noptions_first : bool (default: False)\n    Set to True to require options precede positional arguments,\n    i.e. to forbid options and positional arguments intermix.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>args : dict\n    A dictionary, where keys are names of command-line elements\n    such as e.g. \"--verbose\" and \"<path>\", and values are the\n    parsed values of those elements.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">docopt</span> <span class=\"kn\">import</span> <span class=\"n\">docopt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">doc</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"gp\">... </span><span class=\"s1\">Usage:</span>\n<span class=\"gp\">... </span><span class=\"s1\">    my_program tcp &lt;host&gt; &lt;port&gt; [--timeout=&lt;seconds&gt;]</span>\n<span class=\"gp\">... </span><span class=\"s1\">    my_program serial &lt;port&gt; [--baud=&lt;n&gt;] [--timeout=&lt;seconds&gt;]</span>\n<span class=\"gp\">... </span><span class=\"s1\">    my_program (-h | --help | --version)</span>\n<span class=\"gp\">...</span><span class=\"s1\"></span>\n<span class=\"gp\">... </span><span class=\"s1\">Options:</span>\n<span class=\"gp\">... </span><span class=\"s1\">    -h, --help  Show this screen and exit.</span>\n<span class=\"gp\">... </span><span class=\"s1\">    --baud=&lt;n&gt;  Baudrate [default: 9600]</span>\n<span class=\"gp\">... </span><span class=\"s1\">&#39;&#39;&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">argv</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;tcp&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;127.0.0.1&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;80&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;--timeout&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;30&#39;</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">docopt</span><span class=\"p\">(</span><span class=\"n\">doc</span><span class=\"p\">,</span> <span class=\"n\">argv</span><span class=\"p\">)</span>\n<span class=\"go\">{&#39;--baud&#39;: &#39;9600&#39;,</span>\n<span class=\"go\"> &#39;--help&#39;: False,</span>\n<span class=\"go\"> &#39;--timeout&#39;: &#39;30&#39;,</span>\n<span class=\"go\"> &#39;--version&#39;: False,</span>\n<span class=\"go\"> &#39;&lt;host&gt;&#39;: &#39;127.0.0.1&#39;,</span>\n<span class=\"go\"> &#39;&lt;port&gt;&#39;: &#39;80&#39;,</span>\n<span class=\"go\"> &#39;serial&#39;: False,</span>\n<span class=\"go\"> &#39;tcp&#39;: True}</span>\n</code></pre></div>\n\n<h2 id=\"see-also\">See also</h2>\n\n<ul>\n<li>For video introduction see http://docopt.org</li>\n<li>Full documentation is available in README.rst as well as online\nat https://github.com/docopt/docopt#readme</li>\n</ul>\n", "parameters": ["doc", "argv", "help", "version", "options_first"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.resize_mesh", "modulename": "Blood_Flow_1D.resize_mesh", "qualname": "", "type": "module", "doc": "<p>Usage:\n  resize_mesh.py <mesh_path> <scaling>\n  resize_mesh.py (-h | --help)</p>\n\n<p>Options:\n  -h --help     Show this screen.</p>\n"}, {"fullname": "Blood_Flow_1D.transcript", "modulename": "Blood_Flow_1D.transcript", "qualname": "", "type": "module", "doc": "<p>Transcript - direct print output to a file, in addition to terminal.</p>\n\n<p>Usage:\n    import transcript\n    transcript.start('logfile.log')\n    print(\"inside file\")\n    transcript.stop()\n    print(\"outside file\")</p>\n"}, {"fullname": "Blood_Flow_1D.transcript.Transcript", "modulename": "Blood_Flow_1D.transcript", "qualname": "Transcript", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Blood_Flow_1D.transcript.Transcript.__init__", "modulename": "Blood_Flow_1D.transcript", "qualname": "Transcript.__init__", "type": "function", "doc": "<p>Initiate object</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>filename : str\n    log file name</p>\n", "parameters": ["self", "filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.transcript.Transcript.write", "modulename": "Blood_Flow_1D.transcript", "qualname": "Transcript.write", "type": "function", "doc": "<p>Write message to console and logfile.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>message : str\n    message to print</p>\n", "parameters": ["self", "message"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.transcript.Transcript.flush", "modulename": "Blood_Flow_1D.transcript", "qualname": "Transcript.flush", "type": "function", "doc": "<p>This flush method is needed for python 3 compatibility.\nThis handles the flush command by doing nothing.\nYou might want to specify some extra behavior here.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.transcript.start", "modulename": "Blood_Flow_1D.transcript", "qualname": "start", "type": "function", "doc": "<p>Start transcript, appending print output to given filename.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>filename : str\n    logfile name</p>\n", "parameters": ["filename"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.transcript.stop", "modulename": "Blood_Flow_1D.transcript", "qualname": "stop", "type": "function", "doc": "<p>Stop transcript and return print functionality to normal.</p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.vessel_mapping", "modulename": "Blood_Flow_1D.vessel_mapping", "qualname": "", "type": "module", "doc": "<p>Script to output the perfusion territories of all cerebral vessels and the mapping of the vessels within the network.\nGenerated files are located in bf_sim: \"vesselmapping.vtp\" and \"vesselmapping_network.vtp\".\nUsage:\n  vessel_mapping.py <patient_folder></p>\n"}, {"fullname": "Blood_Flow_1D.vessel_mapping.mapping_function", "modulename": "Blood_Flow_1D.vessel_mapping", "qualname": "mapping_function", "type": "function", "doc": "<p></p>\n", "parameters": ["patient"], "funcdef": "def"}, {"fullname": "Blood_Flow_1D.vessel_mapping.blood_flow_script", "modulename": "Blood_Flow_1D.vessel_mapping", "qualname": "blood_flow_script", "type": "function", "doc": "<p></p>\n", "parameters": ["patient_folder"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();